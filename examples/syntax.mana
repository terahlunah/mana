# test with delimiters

meta [| 
    author: "Terah", 
    title: "Titre"
|]

size(640, 360)
background(0)

let gridSize = 40

let add1 = { it + 1 }
let debug = { print "Debug" }

range(gridSize, width - gridSize, gridSize) { |x|
    range(gridSize, height - gridSize, gridSize) { |y|
        noStroke()
        fill(255)
        rect(x-1, y-1, 3, 3)
        stroke(255, 100)
        line(x, y, width/2, height/2)
    }
}

[2, 2].map { it + 2 }.sorted
[2, 2] |> map { it + 2 } |> sorted

# test functional style

meta #[ 
    author: "Terah", 
    title: "Titre"
|

size 640 360
background 0

let gridSize = 40

let add1 = { it + 1 }
let debug = { print "Debug" }

range gridSize (width - gridSize) gridSize { |x|
    range gridSize (height - gridSize) gridSize { |y|
        noStroke
        fill 255
        rect x-1, y-1, 3, 3
        stroke 255, 100
        line x, y, width/2, height/2
    }
}

# test with indentation

[1, 2, 3, 4]

[age: 2, name: "Tom"]

# Tests

(defn is-small? [number]
  (if (< number 100) "yes" "no"))
  
def is-small? =
  -> n
  n 100 <
    ("yes")
    ("no")
    if

true ("something") when

def foo =
  -> a
  {
    :key "value"
    :key2 a
  }

 
# New
def some = -> x [:some x]
def none = [:none ()]
def map f o = 
    match o with
        [:some s] -> some (f o)
        [:none _] -> o
def okOr e o =
    match o with
        [:some s] ->  ok s
        [:none _] ->  err e


mod Result
    def ok x = ['ok: x]
    def err e = ['err: e]
    def map f r = 
        match r with
            [ok: x] -> ok (f x)
            [err: _] ->  r
    def mapErr f r =
        match r with
            [ok: _] -> r
            [err: e] -> err (f e)
    def ok r =
        match r with
            [ok: x] -> Option.some x
            [err: _] -> Option.none
 

def checkedDiv dividend divisor = 
    if divisor == 0 then
        Option.none
    else
        Option.some (/ dividend divisor)

def tryDiv dividend divisor =
    match (checkedDiv dividend divisor) with
        #[none: _] -> println $"{divident} / {divisor} failed"
        #[some: quotient] -> println $"{divident} / {divisor} = {quotient}"
    
def main =
    tryDiv 4 2
    tryDiv 1 0
    o = Option.some 2
    o2 = Option.map { it + 1 } o # using a lambda with implicit `it` parameter
    
    match (2+3) with # Matching numbers
        2 -> println "Nope"
        5 -> println "Yes"
        _ -> println "Something else"


def circle r = ['radius: r]
def area c = c.radius * c.radius * PI
def area c = (get 'radius c) * (get 'radius c)  * PI


let d = [:]
set 'a 0 d
get 'a d
d['a] # get
d.a # get symbol
d?a # try get symbol
let ['a:a,..] = ['a:2, 'b:3] 

let l = []
push 0 l
pop l
0::l # push
l[0] # get
head l
tail l
rev l
let [a, ..]